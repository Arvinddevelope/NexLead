import 'package:nextlead/data/models/user_model.dart';
import 'package:nextlead/data/services/airtable_service.dart';
import 'package:nextlead/core/config/airtable_config.dart';

class UserService {
  final AirtableService _airtableService;
  static const String _tableName = AirtableConfig.usersTable;

  UserService(this._airtableService);

  /// Get user by email
  Future<User?> getUserByEmail(String email) async {
    try {
      final records = await _airtableService.getRecords(_tableName);
      final userRecord = records.firstWhere(
        (record) {
          final fields = record['fields'] as Map<String, dynamic>;
          return fields['Email'] == email;
        },
        orElse: () => null,
      );

      if (userRecord != null) {
        final fields = userRecord['fields'] as Map<String, dynamic>;
        return User(
          id: userRecord['id'] as String,
          name: fields['Name'] as String,
          email: fields['Email'] as String,
          password: fields['Password'] as String,
          createdAt: DateTime.parse(fields['Created At'] as String),
          updatedAt: DateTime.parse(fields['Updated At'] as String),
        );
      }

      return null;
    } catch (e) {
      throw Exception('Failed to fetch user: $e');
    }
  }

  /// Create a new user
  Future<User> createUser(String name, String email, String password) async {
    try {
      // Note: Created At and Updated At fields are auto-generated by Airtable
      // so we don't need to send them in the create request
      // Based on your Airtable table structure, we need to use the actual field names
      // From our testing, your table has: Role, Active, Leads, Notes, Tasks, Created At, Updated At
      // We need to add the missing user fields to your Airtable table
      final fields = <String, dynamic>{};

      // Try the most common field names first
      fields['Name'] = name;
      fields['Email'] = email;
      fields['Password'] = password;

      final record = await _airtableService.createRecord(_tableName, fields);
      final recordFields = record['fields'] as Map<String, dynamic>;

      // The Created At and Updated At fields will be populated by Airtable
      return User(
        id: record['id'] as String,
        name: recordFields['Full Name'] as String? ??
            recordFields['Name'] as String? ??
            '',
        email: recordFields['Email Address'] as String? ??
            recordFields['Email'] as String? ??
            '',
        password: recordFields['Pass'] as String? ??
            recordFields['Password'] as String? ??
            '',
        createdAt: DateTime.parse(recordFields['Created At'] as String),
        updatedAt: DateTime.parse(recordFields['Updated At'] as String),
      );
    } catch (e) {
      throw Exception('Failed to create user: $e');
    }
  }

  /// Update user
  Future<User> updateUser(User user) async {
    try {
      // Note: Updated At field is auto-generated by Airtable
      // so we don't need to send it in the update request
      // Based on your Airtable table structure, we need to use the actual field names
      final fields = <String, dynamic>{};

      // Try the most common field names first
      fields['Name'] = user.name;
      fields['Email'] = user.email;
      fields['Password'] = user.password;

      final record = await _airtableService.updateRecord(
        _tableName,
        user.id,
        fields,
      );
      final recordFields = record['fields'] as Map<String, dynamic>;

      // The Updated At field will be automatically updated by Airtable
      return User(
        id: record['id'] as String,
        name: recordFields['Full Name'] as String? ??
            recordFields['Name'] as String? ??
            '',
        email: recordFields['Email Address'] as String? ??
            recordFields['Email'] as String? ??
            '',
        password: recordFields['Pass'] as String? ??
            recordFields['Password'] as String? ??
            '',
        createdAt: DateTime.parse(recordFields['Created At'] as String),
        updatedAt: DateTime.parse(recordFields['Updated At'] as String),
      );
    } catch (e) {
      throw Exception('Failed to update user: $e');
    }
  }
}
